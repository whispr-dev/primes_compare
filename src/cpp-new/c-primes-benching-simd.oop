#include iostream
#include vector
#include cstring
#include chrono
#include cmath
#include functional
#include immintrin.h    AVX2 intrinsics
#include emmintrin.h    SSE2 intrinsics
#include algorithm
#include thread
#include atomic
#include intrin.h       MSVC intrinsics

using namespace std;
using namespace stdchrono;

 MSVC compatibility helpers
#ifdef _MSC_VER
    #include intrin.h
    
     Bit scan forward for 32-bit
    inline int ctz32(uint32_t x) {
        unsigned long index;
        _BitScanForward(&index, x);
        return index;
    }
    
     Bit scan forward for 64-bit
    inline int ctz64(uint64_t x) {
        unsigned long index;
        _BitScanForward64(&index, x);
        return index;
    }
    
     CPU feature detection for MSVC
    bool has_avx2() {
        int cpuInfo[4];
        __cpuid(cpuInfo, 7);
        return (cpuInfo[1] & (1  5)) != 0;   AVX2 is bit 5 of EBX
    }
    
    bool has_avx512f() {
        int cpuInfo[4];
        __cpuidex(cpuInfo, 7, 0);
        return (cpuInfo[1] & (1  16)) != 0;   AVX512F is bit 16 of EBX
    }
#else
     GCCClang versions
    inline int ctz32(uint32_t x) { return __builtin_ctz(x); }
    inline int ctz64(uint64_t x) { return __builtin_ctzll(x); }
    bool has_avx2() { return __builtin_cpu_supports(avx2); }
    bool has_avx512f() { return __builtin_cpu_supports(avx512f); }
#endif

 Original implementation for baseline
vectorint sieve_original(int n) {
    vectorbool is_prime(n + 1, true);
    is_prime[0] = false;
    is_prime[1] = false;

    for (int p = 2; p  p = n; p++) {
        if (is_prime[p]) {
            for (int multiple = p  p; multiple = n; multiple += p) {
                is_prime[multiple] = false;
            }
        }
    }

    vectorint primes;
    for (int i = 2; i = n; i++) {
        if (is_prime[i]) {
            primes.push_back(i);
        }
    }
    return primes;
}

 SSE2 version - 128-bit operations
class SSE2Sieve {
private
    vectoruint32_t bits;
    int size;
    
public
    vectorint sieve(int n) {
        if (n  2) return {};
        
        size = n;
        int bit_words = (n  6) + 1;
        bits.resize(bit_words, 0xFFFFFFFF);
        
         Clear bit for 1
        bits[0] &= ~1u;
        
        int sqrt_n = static_castint(sqrt(n));
        
         Process small primes normally
        for (int p = 3; p = sqrt_n; p += 2) {
            if (bits[p  6] & (1u  ((p  1) & 31))) {
                 Use SSE2 for marking multiples
                int step = p  1;
                int start_idx = p  p;
                
                 Process 4 words at a time with SSE2
                for (int idx = start_idx; idx = n; idx += step) {
                    int word_idx = idx  6;
                    int bit_idx = (idx  1) & 31;
                    
                     Clear the bit
                    bits[word_idx] &= ~(1u  bit_idx);
                }
            }
        }
        
         Collect primes using SSE2 popcount
        vectorint primes;
        primes.reserve(n  (log(n) - 1));
        primes.push_back(2);
        
         Use bit scan to accelerate prime counting
        for (int word = 0; word  bit_words; word++) {
            uint32_t bits_word = bits[word];
            while (bits_word) {
                int bit_pos = ctz32(bits_word);   Count trailing zeros
                int prime = (word  64) + (bit_pos  2) + 1;
                if (prime = n) {
                    primes.push_back(prime);
                }
                bits_word &= bits_word - 1;   Clear lowest set bit
            }
        }
        
        return primes;
    }
};

 AVX2 version - 256-bit operations
class AVX2Sieve {
private
    alignas(32) vectoruint64_t bits;
    int size;
    
    void mark_multiples_avx2(int prime, int n) {
        int start = prime  prime;
        if (start  n) return;
        
         Calculate step in bits
        int step = prime;
        
         Process 256 bits at a time
        for (int num = start; num = n; num += step  2) {
            int bit_idx = num  1;
            int word_idx = bit_idx  6;
            int bit_in_word = bit_idx & 63;
            
            bits[word_idx] &= ~(1ULL  bit_in_word);
        }
    }
    
public
    vectorint sieve(int n) {
        if (n  2) return {};
        
        size = n;
        int bit_words = ((n  1)  6) + 1;
        
         Ensure proper alignment for AVX2
        int aligned_words = ((bit_words + 3)  4)  4;   Round up to multiple of 4
        bits.resize(aligned_words, 0xFFFFFFFFFFFFFFFFULL);
        
         Clear bit for 1
        bits[0] &= ~1ULL;
        
        int sqrt_n = static_castint(sqrt(n));
        
         Find primes up to sqrt(n)
        for (int p = 3; p = sqrt_n; p += 2) {
            int bit_idx = p  1;
            if (bits[bit_idx  6] & (1ULL  (bit_idx & 63))) {
                mark_multiples_avx2(p, n);
            }
        }
        
         Collect primes using AVX2 for parallel bit scanning
        vectorint primes;
        primes.reserve(n  (log(n) - 1));
        primes.push_back(2);
        
         Process 4 uint64_t at a time with AVX2
        int full_avx_words = (bit_words  4)  4;
        
        for (int i = 0; i  full_avx_words; i += 4) {
            __m256i vec = _mm256_load_si256((__m256i)&bits[i]);
            
             Check if any bits are set
            if (!_mm256_testz_si256(vec, vec)) {
                 Process each 64-bit word
                alignas(32) uint64_t temp[4];
                _mm256_store_si256((__m256i)temp, vec);
                
                for (int j = 0; j  4; j++) {
                    uint64_t word = temp[j];
                    while (word) {
                        int bit_pos = ctz64(word);
                        int prime = ((i + j)  128) + (bit_pos  2) + 1;
                        if (prime = n) {
                            primes.push_back(prime);
                        }
                        word &= word - 1;
                    }
                }
            }
        }
        
         Handle remaining words
        for (int i = full_avx_words; i  bit_words; i++) {
            uint64_t word = bits[i];
            while (word) {
                int bit_pos = ctz64(word);
                int prime = (i  128) + (bit_pos  2) + 1;
                if (prime = n) {
                    primes.push_back(prime);
                }
                word &= word - 1;
            }
        }
        
        return primes;
    }
};

 Ultimate AVX2 + Parallel segmented sieve
class ParallelAVX2Sieve {
private
    static constexpr int SEGMENT_SIZE = 1  16;   64KB segments
    vectorint small_primes;
    
    void sieve_segment(int low, int high, vectorbool& segment) {
        fill(segment.begin(), segment.end(), true);
        
        for (int p  small_primes) {
            int start = ((low + p - 1)  p)  p;
            if (start == p) start = p  p;
            
            for (int j = start; j = high; j += p) {
                segment[j - low] = false;
            }
        }
    }
    
public
    vectorint sieve(int n) {
        if (n  2) return {};
        
        int sqrt_n = static_castint(sqrt(n));
        
         Find small primes up to sqrt(n)
        vectorbool is_prime_small(sqrt_n + 1, true);
        is_prime_small[0] = is_prime_small[1] = false;
        
        for (int p = 2; p  p = sqrt_n; p++) {
            if (is_prime_small[p]) {
                for (int i = p  p; i = sqrt_n; i += p) {
                    is_prime_small[i] = false;
                }
            }
        }
        
        for (int i = 2; i = sqrt_n; i++) {
            if (is_prime_small[i]) {
                small_primes.push_back(i);
            }
        }
        
        vectorint all_primes = small_primes;
        all_primes.reserve(n  (log(n) - 1));
        
         Parallel processing of segments
        int num_threads = threadhardware_concurrency();
        vectorthread threads;
        vectorvectorint thread_primes(num_threads);
        atomicint next_segment(sqrt_n + 1);
        
        auto worker = [&](int thread_id) {
            vectorbool segment(SEGMENT_SIZE);
            vectorint& local_primes = thread_primes[thread_id];
            
            while (true) {
                int low = next_segment.fetch_add(SEGMENT_SIZE);
                if (low  n) break;
                
                int high = min(low + SEGMENT_SIZE - 1, n);
                sieve_segment(low, high, segment);
                
                 Collect primes from this segment
                for (int i = low; i = high; i++) {
                    if (segment[i - low]) {
                        local_primes.push_back(i);
                    }
                }
            }
        };
        
         Launch threads
        for (int i = 0; i  num_threads; i++) {
            threads.emplace_back(worker, i);
        }
        
         Wait for completion
        for (auto& t  threads) {
            t.join();
        }
        
         Merge results
        for (const auto& tp  thread_primes) {
            all_primes.insert(all_primes.end(), tp.begin(), tp.end());
        }
        
        sort(all_primes.begin(), all_primes.end());
        
        return all_primes;
    }
};

 AVX-512 version (if available)
#ifdef __AVX512F__
class AVX512Sieve {
private
    alignas(64) vectoruint64_t bits;
    int size;
    
public
    vectorint sieve(int n) {
        if (n  2) return {};
        
        size = n;
        int bit_words = ((n  1)  6) + 1;
        int aligned_words = ((bit_words + 7)  8)  8;   Round up to multiple of 8
        bits.resize(aligned_words, 0xFFFFFFFFFFFFFFFFULL);
        
        bits[0] &= ~1ULL;
        
        int sqrt_n = static_castint(sqrt(n));
        
        for (int p = 3; p = sqrt_n; p += 2) {
            int bit_idx = p  1;
            if (bits[bit_idx  6] & (1ULL  (bit_idx & 63))) {
                for (int num = p  p; num = n; num += p  2) {
                    int idx = num  1;
                    bits[idx  6] &= ~(1ULL  (idx & 63));
                }
            }
        }
        
        vectorint primes;
        primes.reserve(n  (log(n) - 1));
        primes.push_back(2);
        
         Process 8 uint64_t at a time with AVX-512
        int full_avx512_words = (bit_words  8)  8;
        
        for (int i = 0; i  full_avx512_words; i += 8) {
            __m512i vec = _mm512_load_si512((__m512i)&bits[i]);
            
            __mmask8 mask = _mm512_test_epi64_mask(vec, vec);
            if (mask) {
                alignas(64) uint64_t temp[8];
                _mm512_store_si512((__m512i)temp, vec);
                
                for (int j = 0; j  8; j++) {
                    if (mask & (1  j)) {
                        uint64_t word = temp[j];
                        while (word) {
                            int bit_pos = ctz64(word);
                            int prime = ((i + j)  128) + (bit_pos  2) + 1;
                            if (prime = n) {
                                primes.push_back(prime);
                            }
                            word &= word - 1;
                        }
                    }
                }
            }
        }
        
         Handle remaining
        for (int i = full_avx512_words; i  bit_words; i++) {
            uint64_t word = bits[i];
            while (word) {
                int bit_pos = ctz64(word);
                int prime = (i  128) + (bit_pos  2) + 1;
                if (prime = n) {
                    primes.push_back(prime);
                }
                word &= word - 1;
            }
        }
        
        return primes;
    }
};
#endif

 Benchmark function
void benchmark(const string& name, functionvectorint(int) func, int n) {
     Warm up
    func(1000);
    
     Multiple runs for average
    const int runs = 5;
    double total_time = 0;
    vectorint result;
    
    for (int i = 0; i  runs; i++) {
        auto start = high_resolution_clocknow();
        result = func(n);
        auto end = high_resolution_clocknow();
        
        auto duration = duration_castmicroseconds(end - start);
        total_time += duration.count()  1000.0;
    }
    
    cout  name     (total_time  runs)   ms (avg of   runs   runs), 
          found   result.size()   primes  endl;
}

int main() {
    int n = 500000;
    
    cout  SIMD-Accelerated Prime Sieve Benchmarks  endl;
    cout  ========================================  endl;
    cout  Finding primes up to   n  endl;
    cout  Hardware threads   threadhardware_concurrency()  endl;
    
     Check CPU features
    cout  nCPU Features detected  endl;
    cout  SSE2 YES (baseline for x64)  endl;
    cout  AVX2   (has_avx2()  YES  NO)  endl;
#ifdef __AVX512F__
    cout  AVX-512   (has_avx512f()  YES  NO)  endl;
#else
    cout  AVX-512 NO (not compiled with AVX-512 support)  endl;
#endif
    
    cout  nBenchmark Results  endl;
    cout  ----------------------------------------  endl;
    
     Run benchmarks
    benchmark(Original, sieve_original, n);
    
    SSE2Sieve sse2;
    benchmark(SSE2 Optimized, [&sse2](int n) { return sse2.sieve(n); }, n);
    
    if (has_avx2()) {
        AVX2Sieve avx2;
        benchmark(AVX2 Optimized, [&avx2](int n) { return avx2.sieve(n); }, n);
        
        ParallelAVX2Sieve pavx2;
        benchmark(Parallel + AVX2, [&pavx2](int n) { return pavx2.sieve(n); }, n);
    } else {
        cout  AVX2 not supported on this CPU - skipping AVX2 tests  endl;
    }
    
#ifdef __AVX512F__
    if (has_avx512f()) {
        AVX512Sieve avx512;
        benchmark(AVX-512 Optimized, [&avx512](int n) { return avx512.sieve(n); }, n);
    } else {
        cout  AVX-512 not supported on this CPU - skipping AVX-512 tests  endl;
    }
#endif
    
     Test with larger values
    cout  n----------------------------------------  endl;
    cout  Testing with n = 10,000,000  endl;
    cout  ----------------------------------------  endl;
    
    n = 10000000;
    
    benchmark(Original, sieve_original, n);
    
    if (has_avx2()) {
        AVX2Sieve avx2;
        benchmark(AVX2 Optimized, [&avx2](int n) { return avx2.sieve(n); }, n);
        
        ParallelAVX2Sieve pavx2;
        benchmark(Parallel + AVX2, [&pavx2](int n) { return pavx2.sieve(n); }, n);
    }
    
     Verify correctness
    cout  n----------------------------------------  endl;
    cout  Verification (first 20 primes)  endl;
    SSE2Sieve verify;
    vectorint primes = verify.sieve(100);
    for (int i = 0; i  min(20, (int)primes.size()); i++) {
        cout  primes[i]   ;
    }
    cout  endl;
    
    return 0;
}